// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `test_proto.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct SimpleProto {
    // message fields
    pub int_field: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SimpleProto {
    fn default() -> &'a SimpleProto {
        <SimpleProto as ::protobuf::Message>::default_instance()
    }
}

impl SimpleProto {
    pub fn new() -> SimpleProto {
        ::std::default::Default::default()
    }

    // int64 int_field = 1;


    pub fn get_int_field(&self) -> i64 {
        self.int_field
    }
    pub fn clear_int_field(&mut self) {
        self.int_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_field(&mut self, v: i64) {
        self.int_field = v;
    }
}

impl ::protobuf::Message for SimpleProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int_field = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.int_field != 0 {
            my_size += ::protobuf::rt::value_size(1, self.int_field, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.int_field != 0 {
            os.write_int64(1, self.int_field)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SimpleProto {
        SimpleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int_field",
                    |m: &SimpleProto| { &m.int_field },
                    |m: &mut SimpleProto| { &mut m.int_field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SimpleProto>(
                    "SimpleProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SimpleProto {
        static mut instance: ::protobuf::lazy::Lazy<SimpleProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SimpleProto,
        };
        unsafe {
            instance.get(SimpleProto::new)
        }
    }
}

impl ::protobuf::Clear for SimpleProto {
    fn clear(&mut self) {
        self.int_field = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SimpleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FullProto {
    // message fields
    pub double_field: f64,
    pub float_field: f32,
    pub int32_field: i32,
    pub int64_field: i64,
    pub uint32_field: u32,
    pub uint64_field: u64,
    pub sint32_field: i32,
    pub sint64_field: i64,
    pub fixed32_field: u32,
    pub fixed64_field: u64,
    pub sfixed32_field: i32,
    pub sfixed64_field: i64,
    pub bool_field: bool,
    pub string_field: ::std::string::String,
    pub bytes_field: ::std::vec::Vec<u8>,
    pub sub_message_field: ::protobuf::SingularPtrField<SubMessage>,
    pub enum_field: FullProto_TestEnum,
    pub repeated_double_field: ::std::vec::Vec<f64>,
    pub repeated_float_field: ::std::vec::Vec<f64>,
    pub repeated_int32_field: ::std::vec::Vec<i32>,
    pub repeated_int64_field: ::std::vec::Vec<i64>,
    pub repeated_uint32_field: ::std::vec::Vec<u32>,
    pub repeated_uint64_field: ::std::vec::Vec<u64>,
    pub repeated_sint32_field: ::std::vec::Vec<i32>,
    pub repeated_sint64_field: ::std::vec::Vec<i64>,
    pub repeated_fixed32_field: ::std::vec::Vec<u32>,
    pub repeated_fixed64_field: ::std::vec::Vec<u64>,
    pub repeated_sfixed32_field: ::std::vec::Vec<i32>,
    pub repeated_sfixed64_field: ::std::vec::Vec<i64>,
    pub repeated_bool_field: ::std::vec::Vec<bool>,
    pub repeated_string_field: ::protobuf::RepeatedField<::std::string::String>,
    pub repeated_bytes_field: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub repeated_sub_message_field: ::protobuf::RepeatedField<SubMessage>,
    pub repeated_enum_field: ::std::vec::Vec<FullProto_TestEnum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FullProto {
    fn default() -> &'a FullProto {
        <FullProto as ::protobuf::Message>::default_instance()
    }
}

impl FullProto {
    pub fn new() -> FullProto {
        ::std::default::Default::default()
    }

    // double double_field = 1;


    pub fn get_double_field(&self) -> f64 {
        self.double_field
    }
    pub fn clear_double_field(&mut self) {
        self.double_field = 0.;
    }

    // Param is passed by value, moved
    pub fn set_double_field(&mut self, v: f64) {
        self.double_field = v;
    }

    // float float_field = 2;


    pub fn get_float_field(&self) -> f32 {
        self.float_field
    }
    pub fn clear_float_field(&mut self) {
        self.float_field = 0.;
    }

    // Param is passed by value, moved
    pub fn set_float_field(&mut self, v: f32) {
        self.float_field = v;
    }

    // int32 int32_field = 3;


    pub fn get_int32_field(&self) -> i32 {
        self.int32_field
    }
    pub fn clear_int32_field(&mut self) {
        self.int32_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_int32_field(&mut self, v: i32) {
        self.int32_field = v;
    }

    // int64 int64_field = 4;


    pub fn get_int64_field(&self) -> i64 {
        self.int64_field
    }
    pub fn clear_int64_field(&mut self) {
        self.int64_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_int64_field(&mut self, v: i64) {
        self.int64_field = v;
    }

    // uint32 uint32_field = 5;


    pub fn get_uint32_field(&self) -> u32 {
        self.uint32_field
    }
    pub fn clear_uint32_field(&mut self) {
        self.uint32_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_uint32_field(&mut self, v: u32) {
        self.uint32_field = v;
    }

    // uint64 uint64_field = 6;


    pub fn get_uint64_field(&self) -> u64 {
        self.uint64_field
    }
    pub fn clear_uint64_field(&mut self) {
        self.uint64_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_uint64_field(&mut self, v: u64) {
        self.uint64_field = v;
    }

    // sint32 sint32_field = 7;


    pub fn get_sint32_field(&self) -> i32 {
        self.sint32_field
    }
    pub fn clear_sint32_field(&mut self) {
        self.sint32_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_sint32_field(&mut self, v: i32) {
        self.sint32_field = v;
    }

    // sint64 sint64_field = 8;


    pub fn get_sint64_field(&self) -> i64 {
        self.sint64_field
    }
    pub fn clear_sint64_field(&mut self) {
        self.sint64_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_sint64_field(&mut self, v: i64) {
        self.sint64_field = v;
    }

    // fixed32 fixed32_field = 9;


    pub fn get_fixed32_field(&self) -> u32 {
        self.fixed32_field
    }
    pub fn clear_fixed32_field(&mut self) {
        self.fixed32_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_fixed32_field(&mut self, v: u32) {
        self.fixed32_field = v;
    }

    // fixed64 fixed64_field = 10;


    pub fn get_fixed64_field(&self) -> u64 {
        self.fixed64_field
    }
    pub fn clear_fixed64_field(&mut self) {
        self.fixed64_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_fixed64_field(&mut self, v: u64) {
        self.fixed64_field = v;
    }

    // sfixed32 sfixed32_field = 11;


    pub fn get_sfixed32_field(&self) -> i32 {
        self.sfixed32_field
    }
    pub fn clear_sfixed32_field(&mut self) {
        self.sfixed32_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_sfixed32_field(&mut self, v: i32) {
        self.sfixed32_field = v;
    }

    // sfixed64 sfixed64_field = 12;


    pub fn get_sfixed64_field(&self) -> i64 {
        self.sfixed64_field
    }
    pub fn clear_sfixed64_field(&mut self) {
        self.sfixed64_field = 0;
    }

    // Param is passed by value, moved
    pub fn set_sfixed64_field(&mut self, v: i64) {
        self.sfixed64_field = v;
    }

    // bool bool_field = 13;


    pub fn get_bool_field(&self) -> bool {
        self.bool_field
    }
    pub fn clear_bool_field(&mut self) {
        self.bool_field = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_field(&mut self, v: bool) {
        self.bool_field = v;
    }

    // string string_field = 14;


    pub fn get_string_field(&self) -> &str {
        &self.string_field
    }
    pub fn clear_string_field(&mut self) {
        self.string_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_field(&mut self, v: ::std::string::String) {
        self.string_field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_field(&mut self) -> &mut ::std::string::String {
        &mut self.string_field
    }

    // Take field
    pub fn take_string_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.string_field, ::std::string::String::new())
    }

    // bytes bytes_field = 15;


    pub fn get_bytes_field(&self) -> &[u8] {
        &self.bytes_field
    }
    pub fn clear_bytes_field(&mut self) {
        self.bytes_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes_field(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_field(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes_field
    }

    // Take field
    pub fn take_bytes_field(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes_field, ::std::vec::Vec::new())
    }

    // .SubMessage sub_message_field = 16;


    pub fn get_sub_message_field(&self) -> &SubMessage {
        self.sub_message_field.as_ref().unwrap_or_else(|| SubMessage::default_instance())
    }
    pub fn clear_sub_message_field(&mut self) {
        self.sub_message_field.clear();
    }

    pub fn has_sub_message_field(&self) -> bool {
        self.sub_message_field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_message_field(&mut self, v: SubMessage) {
        self.sub_message_field = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_message_field(&mut self) -> &mut SubMessage {
        if self.sub_message_field.is_none() {
            self.sub_message_field.set_default();
        }
        self.sub_message_field.as_mut().unwrap()
    }

    // Take field
    pub fn take_sub_message_field(&mut self) -> SubMessage {
        self.sub_message_field.take().unwrap_or_else(|| SubMessage::new())
    }

    // .FullProto.TestEnum enum_field = 17;


    pub fn get_enum_field(&self) -> FullProto_TestEnum {
        self.enum_field
    }
    pub fn clear_enum_field(&mut self) {
        self.enum_field = FullProto_TestEnum::TEST_ENUM_VALUE_A;
    }

    // Param is passed by value, moved
    pub fn set_enum_field(&mut self, v: FullProto_TestEnum) {
        self.enum_field = v;
    }

    // repeated double repeated_double_field = 100;


    pub fn get_repeated_double_field(&self) -> &[f64] {
        &self.repeated_double_field
    }
    pub fn clear_repeated_double_field(&mut self) {
        self.repeated_double_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_double_field(&mut self, v: ::std::vec::Vec<f64>) {
        self.repeated_double_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_double_field(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.repeated_double_field
    }

    // Take field
    pub fn take_repeated_double_field(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.repeated_double_field, ::std::vec::Vec::new())
    }

    // repeated double repeated_float_field = 101;


    pub fn get_repeated_float_field(&self) -> &[f64] {
        &self.repeated_float_field
    }
    pub fn clear_repeated_float_field(&mut self) {
        self.repeated_float_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_float_field(&mut self, v: ::std::vec::Vec<f64>) {
        self.repeated_float_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_float_field(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.repeated_float_field
    }

    // Take field
    pub fn take_repeated_float_field(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.repeated_float_field, ::std::vec::Vec::new())
    }

    // repeated int32 repeated_int32_field = 102;


    pub fn get_repeated_int32_field(&self) -> &[i32] {
        &self.repeated_int32_field
    }
    pub fn clear_repeated_int32_field(&mut self) {
        self.repeated_int32_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int32_field(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_int32_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int32_field(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_int32_field
    }

    // Take field
    pub fn take_repeated_int32_field(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_int32_field, ::std::vec::Vec::new())
    }

    // repeated int64 repeated_int64_field = 103;


    pub fn get_repeated_int64_field(&self) -> &[i64] {
        &self.repeated_int64_field
    }
    pub fn clear_repeated_int64_field(&mut self) {
        self.repeated_int64_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int64_field(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_int64_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int64_field(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_int64_field
    }

    // Take field
    pub fn take_repeated_int64_field(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_int64_field, ::std::vec::Vec::new())
    }

    // repeated uint32 repeated_uint32_field = 104;


    pub fn get_repeated_uint32_field(&self) -> &[u32] {
        &self.repeated_uint32_field
    }
    pub fn clear_repeated_uint32_field(&mut self) {
        self.repeated_uint32_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_uint32_field(&mut self, v: ::std::vec::Vec<u32>) {
        self.repeated_uint32_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_uint32_field(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.repeated_uint32_field
    }

    // Take field
    pub fn take_repeated_uint32_field(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.repeated_uint32_field, ::std::vec::Vec::new())
    }

    // repeated uint64 repeated_uint64_field = 105;


    pub fn get_repeated_uint64_field(&self) -> &[u64] {
        &self.repeated_uint64_field
    }
    pub fn clear_repeated_uint64_field(&mut self) {
        self.repeated_uint64_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_uint64_field(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_uint64_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_uint64_field(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_uint64_field
    }

    // Take field
    pub fn take_repeated_uint64_field(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_uint64_field, ::std::vec::Vec::new())
    }

    // repeated sint32 repeated_sint32_field = 106;


    pub fn get_repeated_sint32_field(&self) -> &[i32] {
        &self.repeated_sint32_field
    }
    pub fn clear_repeated_sint32_field(&mut self) {
        self.repeated_sint32_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sint32_field(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_sint32_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sint32_field(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_sint32_field
    }

    // Take field
    pub fn take_repeated_sint32_field(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_sint32_field, ::std::vec::Vec::new())
    }

    // repeated sint64 repeated_sint64_field = 107;


    pub fn get_repeated_sint64_field(&self) -> &[i64] {
        &self.repeated_sint64_field
    }
    pub fn clear_repeated_sint64_field(&mut self) {
        self.repeated_sint64_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sint64_field(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_sint64_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sint64_field(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_sint64_field
    }

    // Take field
    pub fn take_repeated_sint64_field(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_sint64_field, ::std::vec::Vec::new())
    }

    // repeated fixed32 repeated_fixed32_field = 108;


    pub fn get_repeated_fixed32_field(&self) -> &[u32] {
        &self.repeated_fixed32_field
    }
    pub fn clear_repeated_fixed32_field(&mut self) {
        self.repeated_fixed32_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed32_field(&mut self, v: ::std::vec::Vec<u32>) {
        self.repeated_fixed32_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed32_field(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.repeated_fixed32_field
    }

    // Take field
    pub fn take_repeated_fixed32_field(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.repeated_fixed32_field, ::std::vec::Vec::new())
    }

    // repeated fixed64 repeated_fixed64_field = 109;


    pub fn get_repeated_fixed64_field(&self) -> &[u64] {
        &self.repeated_fixed64_field
    }
    pub fn clear_repeated_fixed64_field(&mut self) {
        self.repeated_fixed64_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed64_field(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_fixed64_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed64_field(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_fixed64_field
    }

    // Take field
    pub fn take_repeated_fixed64_field(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_fixed64_field, ::std::vec::Vec::new())
    }

    // repeated sfixed32 repeated_sfixed32_field = 110;


    pub fn get_repeated_sfixed32_field(&self) -> &[i32] {
        &self.repeated_sfixed32_field
    }
    pub fn clear_repeated_sfixed32_field(&mut self) {
        self.repeated_sfixed32_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sfixed32_field(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_sfixed32_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sfixed32_field(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_sfixed32_field
    }

    // Take field
    pub fn take_repeated_sfixed32_field(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_sfixed32_field, ::std::vec::Vec::new())
    }

    // repeated sfixed64 repeated_sfixed64_field = 111;


    pub fn get_repeated_sfixed64_field(&self) -> &[i64] {
        &self.repeated_sfixed64_field
    }
    pub fn clear_repeated_sfixed64_field(&mut self) {
        self.repeated_sfixed64_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sfixed64_field(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_sfixed64_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sfixed64_field(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_sfixed64_field
    }

    // Take field
    pub fn take_repeated_sfixed64_field(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_sfixed64_field, ::std::vec::Vec::new())
    }

    // repeated bool repeated_bool_field = 112;


    pub fn get_repeated_bool_field(&self) -> &[bool] {
        &self.repeated_bool_field
    }
    pub fn clear_repeated_bool_field(&mut self) {
        self.repeated_bool_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_bool_field(&mut self, v: ::std::vec::Vec<bool>) {
        self.repeated_bool_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_bool_field(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.repeated_bool_field
    }

    // Take field
    pub fn take_repeated_bool_field(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.repeated_bool_field, ::std::vec::Vec::new())
    }

    // repeated string repeated_string_field = 113;


    pub fn get_repeated_string_field(&self) -> &[::std::string::String] {
        &self.repeated_string_field
    }
    pub fn clear_repeated_string_field(&mut self) {
        self.repeated_string_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_string_field(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repeated_string_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_string_field(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repeated_string_field
    }

    // Take field
    pub fn take_repeated_string_field(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repeated_string_field, ::protobuf::RepeatedField::new())
    }

    // repeated bytes repeated_bytes_field = 114;


    pub fn get_repeated_bytes_field(&self) -> &[::std::vec::Vec<u8>] {
        &self.repeated_bytes_field
    }
    pub fn clear_repeated_bytes_field(&mut self) {
        self.repeated_bytes_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_bytes_field(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.repeated_bytes_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_bytes_field(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.repeated_bytes_field
    }

    // Take field
    pub fn take_repeated_bytes_field(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.repeated_bytes_field, ::protobuf::RepeatedField::new())
    }

    // repeated .SubMessage repeated_sub_message_field = 115;


    pub fn get_repeated_sub_message_field(&self) -> &[SubMessage] {
        &self.repeated_sub_message_field
    }
    pub fn clear_repeated_sub_message_field(&mut self) {
        self.repeated_sub_message_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sub_message_field(&mut self, v: ::protobuf::RepeatedField<SubMessage>) {
        self.repeated_sub_message_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sub_message_field(&mut self) -> &mut ::protobuf::RepeatedField<SubMessage> {
        &mut self.repeated_sub_message_field
    }

    // Take field
    pub fn take_repeated_sub_message_field(&mut self) -> ::protobuf::RepeatedField<SubMessage> {
        ::std::mem::replace(&mut self.repeated_sub_message_field, ::protobuf::RepeatedField::new())
    }

    // repeated .FullProto.TestEnum repeated_enum_field = 116;


    pub fn get_repeated_enum_field(&self) -> &[FullProto_TestEnum] {
        &self.repeated_enum_field
    }
    pub fn clear_repeated_enum_field(&mut self) {
        self.repeated_enum_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_enum_field(&mut self, v: ::std::vec::Vec<FullProto_TestEnum>) {
        self.repeated_enum_field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_enum_field(&mut self) -> &mut ::std::vec::Vec<FullProto_TestEnum> {
        &mut self.repeated_enum_field
    }

    // Take field
    pub fn take_repeated_enum_field(&mut self) -> ::std::vec::Vec<FullProto_TestEnum> {
        ::std::mem::replace(&mut self.repeated_enum_field, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FullProto {
    fn is_initialized(&self) -> bool {
        for v in &self.sub_message_field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_sub_message_field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double_field = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_field = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int32_field = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int64_field = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uint32_field = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uint64_field = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.sint32_field = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sint64_field = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.fixed32_field = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.fixed64_field = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.sfixed32_field = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.sfixed64_field = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_field = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.string_field)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytes_field)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sub_message_field)?;
                },
                17 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.enum_field, 17, &mut self.unknown_fields)?
                },
                100 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.repeated_double_field)?;
                },
                101 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.repeated_float_field)?;
                },
                102 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.repeated_int32_field)?;
                },
                103 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.repeated_int64_field)?;
                },
                104 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.repeated_uint32_field)?;
                },
                105 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.repeated_uint64_field)?;
                },
                106 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.repeated_sint32_field)?;
                },
                107 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.repeated_sint64_field)?;
                },
                108 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.repeated_fixed32_field)?;
                },
                109 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.repeated_fixed64_field)?;
                },
                110 => {
                    ::protobuf::rt::read_repeated_sfixed32_into(wire_type, is, &mut self.repeated_sfixed32_field)?;
                },
                111 => {
                    ::protobuf::rt::read_repeated_sfixed64_into(wire_type, is, &mut self.repeated_sfixed64_field)?;
                },
                112 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.repeated_bool_field)?;
                },
                113 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repeated_string_field)?;
                },
                114 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.repeated_bytes_field)?;
                },
                115 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_sub_message_field)?;
                },
                116 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.repeated_enum_field, 116, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.double_field != 0. {
            my_size += 9;
        }
        if self.float_field != 0. {
            my_size += 5;
        }
        if self.int32_field != 0 {
            my_size += ::protobuf::rt::value_size(3, self.int32_field, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int64_field != 0 {
            my_size += ::protobuf::rt::value_size(4, self.int64_field, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uint32_field != 0 {
            my_size += ::protobuf::rt::value_size(5, self.uint32_field, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uint64_field != 0 {
            my_size += ::protobuf::rt::value_size(6, self.uint64_field, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sint32_field != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.sint32_field);
        }
        if self.sint64_field != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.sint64_field);
        }
        if self.fixed32_field != 0 {
            my_size += 5;
        }
        if self.fixed64_field != 0 {
            my_size += 9;
        }
        if self.sfixed32_field != 0 {
            my_size += 5;
        }
        if self.sfixed64_field != 0 {
            my_size += 9;
        }
        if self.bool_field != false {
            my_size += 2;
        }
        if !self.string_field.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.string_field);
        }
        if !self.bytes_field.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.bytes_field);
        }
        if let Some(ref v) = self.sub_message_field.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enum_field != FullProto_TestEnum::TEST_ENUM_VALUE_A {
            my_size += ::protobuf::rt::enum_size(17, self.enum_field);
        }
        my_size += 10 * self.repeated_double_field.len() as u32;
        my_size += 10 * self.repeated_float_field.len() as u32;
        for value in &self.repeated_int32_field {
            my_size += ::protobuf::rt::value_size(102, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_int64_field {
            my_size += ::protobuf::rt::value_size(103, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_uint32_field {
            my_size += ::protobuf::rt::value_size(104, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_uint64_field {
            my_size += ::protobuf::rt::value_size(105, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_sint32_field {
            my_size += ::protobuf::rt::value_varint_zigzag_size(106, *value);
        };
        for value in &self.repeated_sint64_field {
            my_size += ::protobuf::rt::value_varint_zigzag_size(107, *value);
        };
        my_size += 6 * self.repeated_fixed32_field.len() as u32;
        my_size += 10 * self.repeated_fixed64_field.len() as u32;
        my_size += 6 * self.repeated_sfixed32_field.len() as u32;
        my_size += 10 * self.repeated_sfixed64_field.len() as u32;
        my_size += 3 * self.repeated_bool_field.len() as u32;
        for value in &self.repeated_string_field {
            my_size += ::protobuf::rt::string_size(113, &value);
        };
        for value in &self.repeated_bytes_field {
            my_size += ::protobuf::rt::bytes_size(114, &value);
        };
        for value in &self.repeated_sub_message_field {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.repeated_enum_field {
            my_size += ::protobuf::rt::enum_size(116, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.double_field != 0. {
            os.write_double(1, self.double_field)?;
        }
        if self.float_field != 0. {
            os.write_float(2, self.float_field)?;
        }
        if self.int32_field != 0 {
            os.write_int32(3, self.int32_field)?;
        }
        if self.int64_field != 0 {
            os.write_int64(4, self.int64_field)?;
        }
        if self.uint32_field != 0 {
            os.write_uint32(5, self.uint32_field)?;
        }
        if self.uint64_field != 0 {
            os.write_uint64(6, self.uint64_field)?;
        }
        if self.sint32_field != 0 {
            os.write_sint32(7, self.sint32_field)?;
        }
        if self.sint64_field != 0 {
            os.write_sint64(8, self.sint64_field)?;
        }
        if self.fixed32_field != 0 {
            os.write_fixed32(9, self.fixed32_field)?;
        }
        if self.fixed64_field != 0 {
            os.write_fixed64(10, self.fixed64_field)?;
        }
        if self.sfixed32_field != 0 {
            os.write_sfixed32(11, self.sfixed32_field)?;
        }
        if self.sfixed64_field != 0 {
            os.write_sfixed64(12, self.sfixed64_field)?;
        }
        if self.bool_field != false {
            os.write_bool(13, self.bool_field)?;
        }
        if !self.string_field.is_empty() {
            os.write_string(14, &self.string_field)?;
        }
        if !self.bytes_field.is_empty() {
            os.write_bytes(15, &self.bytes_field)?;
        }
        if let Some(ref v) = self.sub_message_field.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enum_field != FullProto_TestEnum::TEST_ENUM_VALUE_A {
            os.write_enum(17, self.enum_field.value())?;
        }
        for v in &self.repeated_double_field {
            os.write_double(100, *v)?;
        };
        for v in &self.repeated_float_field {
            os.write_double(101, *v)?;
        };
        for v in &self.repeated_int32_field {
            os.write_int32(102, *v)?;
        };
        for v in &self.repeated_int64_field {
            os.write_int64(103, *v)?;
        };
        for v in &self.repeated_uint32_field {
            os.write_uint32(104, *v)?;
        };
        for v in &self.repeated_uint64_field {
            os.write_uint64(105, *v)?;
        };
        for v in &self.repeated_sint32_field {
            os.write_sint32(106, *v)?;
        };
        for v in &self.repeated_sint64_field {
            os.write_sint64(107, *v)?;
        };
        for v in &self.repeated_fixed32_field {
            os.write_fixed32(108, *v)?;
        };
        for v in &self.repeated_fixed64_field {
            os.write_fixed64(109, *v)?;
        };
        for v in &self.repeated_sfixed32_field {
            os.write_sfixed32(110, *v)?;
        };
        for v in &self.repeated_sfixed64_field {
            os.write_sfixed64(111, *v)?;
        };
        for v in &self.repeated_bool_field {
            os.write_bool(112, *v)?;
        };
        for v in &self.repeated_string_field {
            os.write_string(113, &v)?;
        };
        for v in &self.repeated_bytes_field {
            os.write_bytes(114, &v)?;
        };
        for v in &self.repeated_sub_message_field {
            os.write_tag(115, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.repeated_enum_field {
            os.write_enum(116, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FullProto {
        FullProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double_field",
                    |m: &FullProto| { &m.double_field },
                    |m: &mut FullProto| { &mut m.double_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float_field",
                    |m: &FullProto| { &m.float_field },
                    |m: &mut FullProto| { &mut m.float_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int32_field",
                    |m: &FullProto| { &m.int32_field },
                    |m: &mut FullProto| { &mut m.int32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int64_field",
                    |m: &FullProto| { &m.int64_field },
                    |m: &mut FullProto| { &mut m.int64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "uint32_field",
                    |m: &FullProto| { &m.uint32_field },
                    |m: &mut FullProto| { &mut m.uint32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uint64_field",
                    |m: &FullProto| { &m.uint64_field },
                    |m: &mut FullProto| { &mut m.uint64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "sint32_field",
                    |m: &FullProto| { &m.sint32_field },
                    |m: &mut FullProto| { &mut m.sint32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "sint64_field",
                    |m: &FullProto| { &m.sint64_field },
                    |m: &mut FullProto| { &mut m.sint64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "fixed32_field",
                    |m: &FullProto| { &m.fixed32_field },
                    |m: &mut FullProto| { &mut m.fixed32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "fixed64_field",
                    |m: &FullProto| { &m.fixed64_field },
                    |m: &mut FullProto| { &mut m.fixed64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "sfixed32_field",
                    |m: &FullProto| { &m.sfixed32_field },
                    |m: &mut FullProto| { &mut m.sfixed32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "sfixed64_field",
                    |m: &FullProto| { &m.sfixed64_field },
                    |m: &mut FullProto| { &mut m.sfixed64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bool_field",
                    |m: &FullProto| { &m.bool_field },
                    |m: &mut FullProto| { &mut m.bool_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_field",
                    |m: &FullProto| { &m.string_field },
                    |m: &mut FullProto| { &mut m.string_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytes_field",
                    |m: &FullProto| { &m.bytes_field },
                    |m: &mut FullProto| { &mut m.bytes_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubMessage>>(
                    "sub_message_field",
                    |m: &FullProto| { &m.sub_message_field },
                    |m: &mut FullProto| { &mut m.sub_message_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FullProto_TestEnum>>(
                    "enum_field",
                    |m: &FullProto| { &m.enum_field },
                    |m: &mut FullProto| { &mut m.enum_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "repeated_double_field",
                    |m: &FullProto| { &m.repeated_double_field },
                    |m: &mut FullProto| { &mut m.repeated_double_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "repeated_float_field",
                    |m: &FullProto| { &m.repeated_float_field },
                    |m: &mut FullProto| { &mut m.repeated_float_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "repeated_int32_field",
                    |m: &FullProto| { &m.repeated_int32_field },
                    |m: &mut FullProto| { &mut m.repeated_int32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "repeated_int64_field",
                    |m: &FullProto| { &m.repeated_int64_field },
                    |m: &mut FullProto| { &mut m.repeated_int64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "repeated_uint32_field",
                    |m: &FullProto| { &m.repeated_uint32_field },
                    |m: &mut FullProto| { &mut m.repeated_uint32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "repeated_uint64_field",
                    |m: &FullProto| { &m.repeated_uint64_field },
                    |m: &mut FullProto| { &mut m.repeated_uint64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "repeated_sint32_field",
                    |m: &FullProto| { &m.repeated_sint32_field },
                    |m: &mut FullProto| { &mut m.repeated_sint32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "repeated_sint64_field",
                    |m: &FullProto| { &m.repeated_sint64_field },
                    |m: &mut FullProto| { &mut m.repeated_sint64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "repeated_fixed32_field",
                    |m: &FullProto| { &m.repeated_fixed32_field },
                    |m: &mut FullProto| { &mut m.repeated_fixed32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "repeated_fixed64_field",
                    |m: &FullProto| { &m.repeated_fixed64_field },
                    |m: &mut FullProto| { &mut m.repeated_fixed64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "repeated_sfixed32_field",
                    |m: &FullProto| { &m.repeated_sfixed32_field },
                    |m: &mut FullProto| { &mut m.repeated_sfixed32_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "repeated_sfixed64_field",
                    |m: &FullProto| { &m.repeated_sfixed64_field },
                    |m: &mut FullProto| { &mut m.repeated_sfixed64_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "repeated_bool_field",
                    |m: &FullProto| { &m.repeated_bool_field },
                    |m: &mut FullProto| { &mut m.repeated_bool_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repeated_string_field",
                    |m: &FullProto| { &m.repeated_string_field },
                    |m: &mut FullProto| { &mut m.repeated_string_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "repeated_bytes_field",
                    |m: &FullProto| { &m.repeated_bytes_field },
                    |m: &mut FullProto| { &mut m.repeated_bytes_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubMessage>>(
                    "repeated_sub_message_field",
                    |m: &FullProto| { &m.repeated_sub_message_field },
                    |m: &mut FullProto| { &mut m.repeated_sub_message_field },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FullProto_TestEnum>>(
                    "repeated_enum_field",
                    |m: &FullProto| { &m.repeated_enum_field },
                    |m: &mut FullProto| { &mut m.repeated_enum_field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FullProto>(
                    "FullProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FullProto {
        static mut instance: ::protobuf::lazy::Lazy<FullProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FullProto,
        };
        unsafe {
            instance.get(FullProto::new)
        }
    }
}

impl ::protobuf::Clear for FullProto {
    fn clear(&mut self) {
        self.double_field = 0.;
        self.float_field = 0.;
        self.int32_field = 0;
        self.int64_field = 0;
        self.uint32_field = 0;
        self.uint64_field = 0;
        self.sint32_field = 0;
        self.sint64_field = 0;
        self.fixed32_field = 0;
        self.fixed64_field = 0;
        self.sfixed32_field = 0;
        self.sfixed64_field = 0;
        self.bool_field = false;
        self.string_field.clear();
        self.bytes_field.clear();
        self.sub_message_field.clear();
        self.enum_field = FullProto_TestEnum::TEST_ENUM_VALUE_A;
        self.repeated_double_field.clear();
        self.repeated_float_field.clear();
        self.repeated_int32_field.clear();
        self.repeated_int64_field.clear();
        self.repeated_uint32_field.clear();
        self.repeated_uint64_field.clear();
        self.repeated_sint32_field.clear();
        self.repeated_sint64_field.clear();
        self.repeated_fixed32_field.clear();
        self.repeated_fixed64_field.clear();
        self.repeated_sfixed32_field.clear();
        self.repeated_sfixed64_field.clear();
        self.repeated_bool_field.clear();
        self.repeated_string_field.clear();
        self.repeated_bytes_field.clear();
        self.repeated_sub_message_field.clear();
        self.repeated_enum_field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FullProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FullProto_TestEnum {
    TEST_ENUM_VALUE_A = 0,
    TEST_ENUM_VALUE_B = 1,
}

impl ::protobuf::ProtobufEnum for FullProto_TestEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FullProto_TestEnum> {
        match value {
            0 => ::std::option::Option::Some(FullProto_TestEnum::TEST_ENUM_VALUE_A),
            1 => ::std::option::Option::Some(FullProto_TestEnum::TEST_ENUM_VALUE_B),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FullProto_TestEnum] = &[
            FullProto_TestEnum::TEST_ENUM_VALUE_A,
            FullProto_TestEnum::TEST_ENUM_VALUE_B,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FullProto_TestEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FullProto_TestEnum {
}

impl ::std::default::Default for FullProto_TestEnum {
    fn default() -> Self {
        FullProto_TestEnum::TEST_ENUM_VALUE_A
    }
}

impl ::protobuf::reflect::ProtobufValue for FullProto_TestEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubMessage {
    // message fields
    pub sub_string_field: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubMessage {
    fn default() -> &'a SubMessage {
        <SubMessage as ::protobuf::Message>::default_instance()
    }
}

impl SubMessage {
    pub fn new() -> SubMessage {
        ::std::default::Default::default()
    }

    // string sub_string_field = 1;


    pub fn get_sub_string_field(&self) -> &str {
        &self.sub_string_field
    }
    pub fn clear_sub_string_field(&mut self) {
        self.sub_string_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_string_field(&mut self, v: ::std::string::String) {
        self.sub_string_field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_string_field(&mut self) -> &mut ::std::string::String {
        &mut self.sub_string_field
    }

    // Take field
    pub fn take_sub_string_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_string_field, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sub_string_field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sub_string_field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sub_string_field);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sub_string_field.is_empty() {
            os.write_string(1, &self.sub_string_field)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubMessage {
        SubMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sub_string_field",
                    |m: &SubMessage| { &m.sub_string_field },
                    |m: &mut SubMessage| { &mut m.sub_string_field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubMessage>(
                    "SubMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubMessage {
        static mut instance: ::protobuf::lazy::Lazy<SubMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubMessage,
        };
        unsafe {
            instance.get(SubMessage::new)
        }
    }
}

impl ::protobuf::Clear for SubMessage {
    fn clear(&mut self) {
        self.sub_string_field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10test_proto.proto\"*\n\x0bSimpleProto\x12\x1b\n\tint_field\x18\x01\
    \x20\x01(\x03R\x08intField\"\xda\x0c\n\tFullProto\x12!\n\x0cdouble_field\
    \x18\x01\x20\x01(\x01R\x0bdoubleField\x12\x1f\n\x0bfloat_field\x18\x02\
    \x20\x01(\x02R\nfloatField\x12\x1f\n\x0bint32_field\x18\x03\x20\x01(\x05\
    R\nint32Field\x12\x1f\n\x0bint64_field\x18\x04\x20\x01(\x03R\nint64Field\
    \x12!\n\x0cuint32_field\x18\x05\x20\x01(\rR\x0buint32Field\x12!\n\x0cuin\
    t64_field\x18\x06\x20\x01(\x04R\x0buint64Field\x12!\n\x0csint32_field\
    \x18\x07\x20\x01(\x11R\x0bsint32Field\x12!\n\x0csint64_field\x18\x08\x20\
    \x01(\x12R\x0bsint64Field\x12#\n\rfixed32_field\x18\t\x20\x01(\x07R\x0cf\
    ixed32Field\x12#\n\rfixed64_field\x18\n\x20\x01(\x06R\x0cfixed64Field\
    \x12%\n\x0esfixed32_field\x18\x0b\x20\x01(\x0fR\rsfixed32Field\x12%\n\
    \x0esfixed64_field\x18\x0c\x20\x01(\x10R\rsfixed64Field\x12\x1d\n\nbool_\
    field\x18\r\x20\x01(\x08R\tboolField\x12!\n\x0cstring_field\x18\x0e\x20\
    \x01(\tR\x0bstringField\x12\x1f\n\x0bbytes_field\x18\x0f\x20\x01(\x0cR\n\
    bytesField\x127\n\x11sub_message_field\x18\x10\x20\x01(\x0b2\x0b.SubMess\
    ageR\x0fsubMessageField\x122\n\nenum_field\x18\x11\x20\x01(\x0e2\x13.Ful\
    lProto.TestEnumR\tenumField\x122\n\x15repeated_double_field\x18d\x20\x03\
    (\x01R\x13repeatedDoubleField\x120\n\x14repeated_float_field\x18e\x20\
    \x03(\x01R\x12repeatedFloatField\x120\n\x14repeated_int32_field\x18f\x20\
    \x03(\x05R\x12repeatedInt32Field\x120\n\x14repeated_int64_field\x18g\x20\
    \x03(\x03R\x12repeatedInt64Field\x122\n\x15repeated_uint32_field\x18h\
    \x20\x03(\rR\x13repeatedUint32Field\x122\n\x15repeated_uint64_field\x18i\
    \x20\x03(\x04R\x13repeatedUint64Field\x122\n\x15repeated_sint32_field\
    \x18j\x20\x03(\x11R\x13repeatedSint32Field\x122\n\x15repeated_sint64_fie\
    ld\x18k\x20\x03(\x12R\x13repeatedSint64Field\x124\n\x16repeated_fixed32_\
    field\x18l\x20\x03(\x07R\x14repeatedFixed32Field\x124\n\x16repeated_fixe\
    d64_field\x18m\x20\x03(\x06R\x14repeatedFixed64Field\x126\n\x17repeated_\
    sfixed32_field\x18n\x20\x03(\x0fR\x15repeatedSfixed32Field\x126\n\x17rep\
    eated_sfixed64_field\x18o\x20\x03(\x10R\x15repeatedSfixed64Field\x12.\n\
    \x13repeated_bool_field\x18p\x20\x03(\x08R\x11repeatedBoolField\x122\n\
    \x15repeated_string_field\x18q\x20\x03(\tR\x13repeatedStringField\x120\n\
    \x14repeated_bytes_field\x18r\x20\x03(\x0cR\x12repeatedBytesField\x12H\n\
    \x1arepeated_sub_message_field\x18s\x20\x03(\x0b2\x0b.SubMessageR\x17rep\
    eatedSubMessageField\x12C\n\x13repeated_enum_field\x18t\x20\x03(\x0e2\
    \x13.FullProto.TestEnumR\x11repeatedEnumField\"8\n\x08TestEnum\x12\x15\n\
    \x11TEST_ENUM_VALUE_A\x10\0\x12\x15\n\x11TEST_ENUM_VALUE_B\x10\x01\"6\n\
    \nSubMessage\x12(\n\x10sub_string_field\x18\x01\x20\x01(\tR\x0esubString\
    FieldJ\xdd\x15\n\x06\x12\x04\0\08\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \n\n\x02\x04\0\x12\x04\x02\0\x04\x01\n\n\n\x03\x04\0\x01\x12\x03\x02\x08\
    \x13\n\x0b\n\x04\x04\0\x02\0\x12\x03\x03\x02\x16\n\r\n\x05\x04\0\x02\0\
    \x04\x12\x04\x03\x02\x02\x15\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x03\x02\
    \x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x03\x08\x11\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x03\x14\x15\nL\n\x02\x04\x01\x12\x04\x07\04\x01\x1a@\
    \x20See\x20https://developers.google.com/protocol-buffers/docs/proto3\n\
    \n\n\n\x03\x04\x01\x01\x12\x03\x07\x08\x11\n\x0c\n\x04\x04\x01\x04\0\x12\
    \x04\x08\x02\x0b\x03\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03\x08\x07\x0f\n\
    \r\n\x06\x04\x01\x04\0\x02\0\x12\x03\t\x04\x1a\n\x0e\n\x07\x04\x01\x04\0\
    \x02\0\x01\x12\x03\t\x04\x15\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03\
    \t\x18\x19\n\r\n\x06\x04\x01\x04\0\x02\x01\x12\x03\n\x04\x1a\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x01\x01\x12\x03\n\x04\x15\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x01\x02\x12\x03\n\x18\x19\n\x0b\n\x04\x04\x01\x02\0\x12\x03\r\x02\
    \x1a\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\r\x02\x0b\x03\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\r\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\r\
    \t\x15\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\r\x18\x19\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03\x0e\x02\x18\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\
    \x0e\x02\r\x1a\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0e\x02\x07\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03\x0e\x08\x13\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03\x0e\x16\x17\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x0f\x02\
    \x18\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x0f\x02\x0e\x18\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03\x0f\x02\x07\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x0f\x08\x13\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x0f\x16\x17\
    \n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x10\x02\x18\n\r\n\x05\x04\x01\x02\
    \x03\x04\x12\x04\x10\x02\x0f\x18\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\
    \x10\x02\x07\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x10\x08\x13\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03\x10\x16\x17\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03\x11\x02\x1a\n\r\n\x05\x04\x01\x02\x04\x04\x12\x04\x11\x02\x10\
    \x18\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x11\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\x04\x01\x12\x03\x11\t\x15\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\
    \x03\x11\x18\x19\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x12\x02\x1a\n\r\n\
    \x05\x04\x01\x02\x05\x04\x12\x04\x12\x02\x11\x1a\n\x0c\n\x05\x04\x01\x02\
    \x05\x05\x12\x03\x12\x02\x08\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x12\
    \t\x15\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x12\x18\x19\n\x0b\n\x04\
    \x04\x01\x02\x06\x12\x03\x13\x02\x1a\n\r\n\x05\x04\x01\x02\x06\x04\x12\
    \x04\x13\x02\x12\x1a\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03\x13\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03\x13\t\x15\n\x0c\n\x05\x04\x01\
    \x02\x06\x03\x12\x03\x13\x18\x19\n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x14\
    \x02\x1a\n\r\n\x05\x04\x01\x02\x07\x04\x12\x04\x14\x02\x13\x1a\n\x0c\n\
    \x05\x04\x01\x02\x07\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\x01\x02\x07\
    \x01\x12\x03\x14\t\x15\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\x14\x18\
    \x19\n\x0b\n\x04\x04\x01\x02\x08\x12\x03\x15\x02\x1c\n\r\n\x05\x04\x01\
    \x02\x08\x04\x12\x04\x15\x02\x14\x1a\n\x0c\n\x05\x04\x01\x02\x08\x05\x12\
    \x03\x15\x02\t\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03\x15\n\x17\n\x0c\n\
    \x05\x04\x01\x02\x08\x03\x12\x03\x15\x1a\x1b\n\x0b\n\x04\x04\x01\x02\t\
    \x12\x03\x16\x02\x1d\n\r\n\x05\x04\x01\x02\t\x04\x12\x04\x16\x02\x15\x1c\
    \n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03\x16\x02\t\n\x0c\n\x05\x04\x01\x02\
    \t\x01\x12\x03\x16\n\x17\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03\x16\x1a\
    \x1c\n\x0b\n\x04\x04\x01\x02\n\x12\x03\x17\x02\x1f\n\r\n\x05\x04\x01\x02\
    \n\x04\x12\x04\x17\x02\x16\x1d\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03\x17\
    \x02\n\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03\x17\x0b\x19\n\x0c\n\x05\x04\
    \x01\x02\n\x03\x12\x03\x17\x1c\x1e\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03\
    \x18\x02\x1f\n\r\n\x05\x04\x01\x02\x0b\x04\x12\x04\x18\x02\x17\x1f\n\x0c\
    \n\x05\x04\x01\x02\x0b\x05\x12\x03\x18\x02\n\n\x0c\n\x05\x04\x01\x02\x0b\
    \x01\x12\x03\x18\x0b\x19\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03\x18\x1c\
    \x1e\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03\x19\x02\x17\n\r\n\x05\x04\x01\
    \x02\x0c\x04\x12\x04\x19\x02\x18\x1f\n\x0c\n\x05\x04\x01\x02\x0c\x05\x12\
    \x03\x19\x02\x06\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03\x19\x07\x11\n\
    \x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03\x19\x14\x16\n\x0b\n\x04\x04\x01\
    \x02\r\x12\x03\x1a\x02\x1b\n\r\n\x05\x04\x01\x02\r\x04\x12\x04\x1a\x02\
    \x19\x17\n\x0c\n\x05\x04\x01\x02\r\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\
    \x04\x01\x02\r\x01\x12\x03\x1a\t\x15\n\x0c\n\x05\x04\x01\x02\r\x03\x12\
    \x03\x1a\x18\x1a\n\x0b\n\x04\x04\x01\x02\x0e\x12\x03\x1b\x02\x19\n\r\n\
    \x05\x04\x01\x02\x0e\x04\x12\x04\x1b\x02\x1a\x1b\n\x0c\n\x05\x04\x01\x02\
    \x0e\x05\x12\x03\x1b\x02\x07\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\x03\x1b\
    \x08\x13\n\x0c\n\x05\x04\x01\x02\x0e\x03\x12\x03\x1b\x16\x18\n\x0b\n\x04\
    \x04\x01\x02\x0f\x12\x03\x1c\x02$\n\r\n\x05\x04\x01\x02\x0f\x04\x12\x04\
    \x1c\x02\x1b\x19\n\x0c\n\x05\x04\x01\x02\x0f\x06\x12\x03\x1c\x02\x0c\n\
    \x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03\x1c\r\x1e\n\x0c\n\x05\x04\x01\x02\
    \x0f\x03\x12\x03\x1c!#\n\x0b\n\x04\x04\x01\x02\x10\x12\x03\x1d\x02\x1b\n\
    \r\n\x05\x04\x01\x02\x10\x04\x12\x04\x1d\x02\x1c$\n\x0c\n\x05\x04\x01\
    \x02\x10\x06\x12\x03\x1d\x02\n\n\x0c\n\x05\x04\x01\x02\x10\x01\x12\x03\
    \x1d\x0b\x15\n\x0c\n\x05\x04\x01\x02\x10\x03\x12\x03\x1d\x18\x1a\n\x0b\n\
    \x04\x04\x01\x02\x11\x12\x03\x1f\x02.\n\x0c\n\x05\x04\x01\x02\x11\x04\
    \x12\x03\x1f\x02\n\n\x0c\n\x05\x04\x01\x02\x11\x05\x12\x03\x1f\x0b\x11\n\
    \x0c\n\x05\x04\x01\x02\x11\x01\x12\x03\x1f\x12'\n\x0c\n\x05\x04\x01\x02\
    \x11\x03\x12\x03\x1f*-\n\x0b\n\x04\x04\x01\x02\x12\x12\x03\x20\x02-\n\
    \x0c\n\x05\x04\x01\x02\x12\x04\x12\x03\x20\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x12\x05\x12\x03\x20\x0b\x11\n\x0c\n\x05\x04\x01\x02\x12\x01\x12\x03\x20\
    \x12&\n\x0c\n\x05\x04\x01\x02\x12\x03\x12\x03\x20),\n\x0b\n\x04\x04\x01\
    \x02\x13\x12\x03!\x02,\n\x0c\n\x05\x04\x01\x02\x13\x04\x12\x03!\x02\n\n\
    \x0c\n\x05\x04\x01\x02\x13\x05\x12\x03!\x0b\x10\n\x0c\n\x05\x04\x01\x02\
    \x13\x01\x12\x03!\x11%\n\x0c\n\x05\x04\x01\x02\x13\x03\x12\x03!(+\n\x0b\
    \n\x04\x04\x01\x02\x14\x12\x03\"\x02,\n\x0c\n\x05\x04\x01\x02\x14\x04\
    \x12\x03\"\x02\n\n\x0c\n\x05\x04\x01\x02\x14\x05\x12\x03\"\x0b\x10\n\x0c\
    \n\x05\x04\x01\x02\x14\x01\x12\x03\"\x11%\n\x0c\n\x05\x04\x01\x02\x14\
    \x03\x12\x03\"(+\n\x0b\n\x04\x04\x01\x02\x15\x12\x03#\x02.\n\x0c\n\x05\
    \x04\x01\x02\x15\x04\x12\x03#\x02\n\n\x0c\n\x05\x04\x01\x02\x15\x05\x12\
    \x03#\x0b\x11\n\x0c\n\x05\x04\x01\x02\x15\x01\x12\x03#\x12'\n\x0c\n\x05\
    \x04\x01\x02\x15\x03\x12\x03#*-\n\x0b\n\x04\x04\x01\x02\x16\x12\x03$\x02\
    .\n\x0c\n\x05\x04\x01\x02\x16\x04\x12\x03$\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x16\x05\x12\x03$\x0b\x11\n\x0c\n\x05\x04\x01\x02\x16\x01\x12\x03$\x12'\
    \n\x0c\n\x05\x04\x01\x02\x16\x03\x12\x03$*-\n\x0b\n\x04\x04\x01\x02\x17\
    \x12\x03%\x02.\n\x0c\n\x05\x04\x01\x02\x17\x04\x12\x03%\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x17\x05\x12\x03%\x0b\x11\n\x0c\n\x05\x04\x01\x02\x17\
    \x01\x12\x03%\x12'\n\x0c\n\x05\x04\x01\x02\x17\x03\x12\x03%*-\n\x0b\n\
    \x04\x04\x01\x02\x18\x12\x03&\x02.\n\x0c\n\x05\x04\x01\x02\x18\x04\x12\
    \x03&\x02\n\n\x0c\n\x05\x04\x01\x02\x18\x05\x12\x03&\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x18\x01\x12\x03&\x12'\n\x0c\n\x05\x04\x01\x02\x18\x03\x12\
    \x03&*-\n\x0b\n\x04\x04\x01\x02\x19\x12\x03'\x020\n\x0c\n\x05\x04\x01\
    \x02\x19\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x01\x02\x19\x05\x12\x03'\x0b\
    \x12\n\x0c\n\x05\x04\x01\x02\x19\x01\x12\x03'\x13)\n\x0c\n\x05\x04\x01\
    \x02\x19\x03\x12\x03',/\n\x0b\n\x04\x04\x01\x02\x1a\x12\x03(\x020\n\x0c\
    \n\x05\x04\x01\x02\x1a\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x01\x02\x1a\
    \x05\x12\x03(\x0b\x12\n\x0c\n\x05\x04\x01\x02\x1a\x01\x12\x03(\x13)\n\
    \x0c\n\x05\x04\x01\x02\x1a\x03\x12\x03(,/\n\x0b\n\x04\x04\x01\x02\x1b\
    \x12\x03)\x022\n\x0c\n\x05\x04\x01\x02\x1b\x04\x12\x03)\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x1b\x05\x12\x03)\x0b\x13\n\x0c\n\x05\x04\x01\x02\x1b\
    \x01\x12\x03)\x14+\n\x0c\n\x05\x04\x01\x02\x1b\x03\x12\x03).1\n\x0b\n\
    \x04\x04\x01\x02\x1c\x12\x03*\x022\n\x0c\n\x05\x04\x01\x02\x1c\x04\x12\
    \x03*\x02\n\n\x0c\n\x05\x04\x01\x02\x1c\x05\x12\x03*\x0b\x13\n\x0c\n\x05\
    \x04\x01\x02\x1c\x01\x12\x03*\x14+\n\x0c\n\x05\x04\x01\x02\x1c\x03\x12\
    \x03*.1\n\x0b\n\x04\x04\x01\x02\x1d\x12\x03+\x02*\n\x0c\n\x05\x04\x01\
    \x02\x1d\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\x01\x02\x1d\x05\x12\x03+\x0b\
    \x0f\n\x0c\n\x05\x04\x01\x02\x1d\x01\x12\x03+\x10#\n\x0c\n\x05\x04\x01\
    \x02\x1d\x03\x12\x03+&)\n\x0b\n\x04\x04\x01\x02\x1e\x12\x03,\x02.\n\x0c\
    \n\x05\x04\x01\x02\x1e\x04\x12\x03,\x02\n\n\x0c\n\x05\x04\x01\x02\x1e\
    \x05\x12\x03,\x0b\x11\n\x0c\n\x05\x04\x01\x02\x1e\x01\x12\x03,\x12'\n\
    \x0c\n\x05\x04\x01\x02\x1e\x03\x12\x03,*-\n\x0b\n\x04\x04\x01\x02\x1f\
    \x12\x03-\x02,\n\x0c\n\x05\x04\x01\x02\x1f\x04\x12\x03-\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x1f\x05\x12\x03-\x0b\x10\n\x0c\n\x05\x04\x01\x02\x1f\
    \x01\x12\x03-\x11%\n\x0c\n\x05\x04\x01\x02\x1f\x03\x12\x03-(+\n\x0b\n\
    \x04\x04\x01\x02\x20\x12\x03.\x027\n\x0c\n\x05\x04\x01\x02\x20\x04\x12\
    \x03.\x02\n\n\x0c\n\x05\x04\x01\x02\x20\x06\x12\x03.\x0b\x15\n\x0c\n\x05\
    \x04\x01\x02\x20\x01\x12\x03.\x160\n\x0c\n\x05\x04\x01\x02\x20\x03\x12\
    \x03.36\n\x0b\n\x04\x04\x01\x02!\x12\x03/\x02.\n\x0c\n\x05\x04\x01\x02!\
    \x04\x12\x03/\x02\n\n\x0c\n\x05\x04\x01\x02!\x06\x12\x03/\x0b\x13\n\x0c\
    \n\x05\x04\x01\x02!\x01\x12\x03/\x14'\n\x0c\n\x05\x04\x01\x02!\x03\x12\
    \x03/*-\n\n\n\x02\x04\x02\x12\x046\08\x01\n\n\n\x03\x04\x02\x01\x12\x036\
    \x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\x037\x02\x1e\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x047\x026\x14\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x037\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x037\t\x19\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x037\x1c\x1db\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
